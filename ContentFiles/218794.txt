[this article looks into the details of how the same-site cookie attribute works and how it can be used to help prevent malicious cross-site request forgery (csrf) attacks., because http is a stateless protocol, it cannot internally distinguish one user from another. to address this issue, cookie technology was invented in 1994. by using cookies, servers instruct browsers to save a unique key and then send it back with each request made to the server., when a request is sent from a browser to a website, the browser checks if it has a stored cookie that belongs to that website. while carrying out this process, it checks to see whether the properties and flags of the cookies (domain, path, secure), match the website's data which has been requested. if they match, the browser sends the relevant cookies along with the request., this behavior is also repeated in the same way for requests made by third parties through the browser. by "third parties" we mean other websites that we don't visit directly. the critical point from a web application security perspective is that when you visit website a, all cookies kept in the browser for site b will be added to the request initiated toward site b by site a. so, a session that belongs to b on the browser can be used and even abused in this way., in security terminology, abusing this bevahior of browsers is known as cross-site request forgery (csrf).  it is carried out by misusing a session belonging to an authorized user by using this browser behavior., this browser behavior can also be misused for other purposes like tracking users or advertising. when you enter a site, for instance example.com, your browser may make a few requests to different sites because of the html elements placed on the page of example.com, for example facebook like buttons, google analytics code, etc. along with these requests, the cookies in the browser that belong to these other sites will also be sent. therefore those third parties can track and log your activity by using cookie and referrer information., normally, it is possible to avoid tracking like this in firefox and chrome browsers.  however, when these browsers block tracking, they prevent the sending of cookies along with the request made by any third party website. but by doing so your browsing experience will be very poor. so by blocking cookies, you can totally prevent csrf, but is it worth the consequences?, thanks to a new cookie attribute, that google chrome started supporting on the 29th of march, and other the popular browsers followed, there is now a solution. it is called the same-site cookie attribute. developers can now instruct browsers to control whether cookies are sent along with the request initiated by third party websites - by using the samesite cookie attribute, which is a more practical solution than denying the sending of cookies., setting a same-site attribute to a cookie is quite simple. it consists of adding just one instruction to the cookie.  simply adding 'samesite=lax' or 'samesite=strict' is enough!, set-cookie: cookiename=cookievalue; samesite=lax; set-cookie: cookiename=cookievalue; samesite=strict;, strict: as the name suggests, this is the option in which the same-site rule is applied strictly.  when the samesite attribute is set as strict, the cookie will not be sent along with requests initiated by third party websites., setting a cookie as strict can affect browsing experience negatively. for example, if you click on a link that points to a facebook profile page, and if facebook.com has set its cookie as samesite=strict, you cannot continue navigation on facebook (view the facebook page) unless you log in to facebook again. the reason for this is because facebook`s cookie was not sent by this request., lax: when you set a cookie' samesite attribute to lax, the cookie will be sent along with the get request initiated by third party website., the important point here is that, to send a cookie with a get request, get request being made must cause a top level navigation. only in this way, the cookie set as lax will be sent. let me explain more., , resources can be loaded by iframe, img tags, and script tags. these requests can also operate as get requests, but none of them cause top level navigation. basically, they don't change the url in your address bar. because these get requests do not cause a top level navigation, thus cookies set to lax won't be sent with them., see the table below for more clarification:, yes, it looks like the samesite cookie attribute is an effective security measure against csrf attacks. you can avoid sending your cookies with the request initiated by third parties by using this feature.  let me clarify with an example:,  let's say you are logged in to the website www.badbank.com.  using a phishing attack, an attacker can trick you into entering www.attacker.com in another browser tab. using a code on www.attacker.com, the attacker tries to transfer money from your account by posting a form to www.badbank.com. your browser sends the cookie belonging to www.badbank.com with this request. if the form on www.badbank.com lacks csrf tokens to prevent a csrf attack, your session can be exploited by the attacker., if the cookie of www.badbank.com had been set to samesite=lax, the cookie in the browser would not have been sent with the post request and the attack would not be successful., csrf attacks were at number 5 in the owasp top 10 list published in 2010, but they declined to number 8 in the owasp top ten in 2013. people suggested that the reason for this was increased awareness of csrf and the common use of anti-csrf tokens by frameworks., , source : https://www.owasp.org/index.php/top_10_2013-release_notes, although we're now using the samesite cookie attribute, we should still be cautious! we should make the whole changes with post request instead of get., get is designed for navigational purposes, not for state changes, so using get requests is generally considered a safe method.  however, when we are performing actions (such as ordering a product, changing a password, or editing profile information), using post requests is much safer., there are 3 important reasons for this:, how does netsparker report this?, at netsparker, we are constantly paying attention to the latest security developments and adding new features and security checks into our engine. in fact just a few weeks after the technical details of the same-site cookie attribute were released, we implemented the check for it in both netsparker desktop and netsparker enterprise, therefore the web vulnerability scanner will alert you if cookies do not have such attribute., , , your information will be kept private., your information will be kept private., this article explains in details the various vulnerabilities netsparker’s security researchers identified in cubecart, an open source ecommerce solution., invicti security corp 220 industrial blvd ste 102 austin, tx 78745, © invicti 2022, resources, use cases, web security, company, © invicti 2022][using the same-site cookie attribute to prevent csrf attacks, introduction to web cookies, cookies misuse can lead to cross-site request forgery, should you block cross-site requests to prevent csrf?, introducing the same-site cookie attribute to prevent csrf attacks, differences between the strict and lax samesite cookie attributes, does this really mean "goodbye" to csrf?, csrf popularity is going down, preventing csrf vulnerabilities, related articles, how to protect your website using anti-csrf tokens, cross-site request forgery attacks, the importance of the content-type header in http requests, xss, csrf & other vulnerabilities in cubecart web application]preventing csrf attacks with the samesite cookie attribute | invicti[same-site cookie attribute, strict, lax, request type, example code, cookies sent, how does netsparker report this?][product overview features, why invicti? solutions industries it & telecom government financial education healthcare roles cto & ciso engineering manager security engineer devsecops comparison case studies customers testimonials, pricing, about us our story in the news careers contact us, resources blog white papers buyer's guide resource library partners support, web security blog, web security, news, product releases, product docs & faqs, when the parameters are carried by get, they stay in the browser history. they also will be placed in server logs and the referrer header in the request made toward third parties., another reason for not using get requests is that cookies set to lax are still sent along with get requests, giving attackers another opportunity to exploit users., lastly, exploiting a csrf vulnerability by using get is much easier. to exploit a csrf vulnerability in a form using get, an attacker does not have to own a site. he can inject this payload into a forum message, post comment or image tag., features, integrations, pricing, case studies, advisories, white papers, penetration testing software, website security scanner, ethical hacking software, web vulnerability scanner, comparisons, online application scanner, the problem with false positives, why pay for web scanners, sql injection cheat sheet, getting started with web security, vulnerability index, using content security policy to secure web applications, about us, contact us, support, careers, resources, partners]