[over the last year.&& the tarides storage team has been focused on scaling the storage layer of octez.&& the most popular node implementation for the tezos blockchain. with the upcoming release of octez v13.&& we are reaching our performance goal of supporting one thousand transactions per second (tps) in the storage layer! this is a 6x improvement over octez 10. even better.&& this release also makes the storage layer orders of magnitude more stable.&& with a 12x improvement in the mean latency of operations. at the same time.&& we reduced the memory usage by 80%. now octez requires a mere 400 mb of ram to bootstrap nodes!.&& in this post.&& well explain how we achieved these milestones thanks to irmin 3.&& the new major release of the mirageos-compatible storage layer developed and maintained by tarides and used by tezos. well also explain what this means for the tezos community now and in the future..&& as explained by a recent post on nomadic labs blog.&& there are various ways to evaluate the throughput of tezos. our purpose is to optimise the tezos storage and identify and fix bottlenecks. thus.&& our benchmarking setup replays actual data (the 150k first blocks of the hangzhou protocol on tezos mainnet.&& corresponding to the period dec 2021 â€“ jan 2022) and explicitly excludes the networking i/o operations and protocol computations to focus on the context i/o operations only. thanks to this setup we managed to identify.&& fix.&& and verify that we removed the main i/o bottlenecks present in octez:.&& .&& comparison of the transactions per second (tps) performance between octez 10.&& 11.&& 12 and 13 while replaying the 150k first blocks of the hangzhou protocol on tezos mainnet1. octez 13 reaches 1043 tps on average which is a 6x improvement over octez 10..&& a tezos node keeps track of the blockchain state in a database called the context. for each block observed by the node.&& the context stores a corresponding tree that witnesses the state of the chain at that block..&& each leaf in the tree contains some data (e.g..&& the balance of a particular wallet) which has a unique hash. together these leaf hashes uniquely determine the hashes of their parent nodes all the way up to the root hash of the tree. in the other direction â€“ moving down the tree from the root â€“ these hashes form addresses that allow each node to later be recovered from disk. in the octez node.&& the context is implemented using irmin.&& an open-source ocaml library that solves exactly this problem: storing trees of data in which each node is addressed by its hash..&& as with any database.&& a crucial aspect of irmins implementation is its index.&& the component that maps addresses to data locations (in this case.&& mapping hashes to offsets within a large append-only data file). indexing each object in the store by hash has some important advantages: for instance.&& it ensures that the database is totally deduplicated and enables fast random access to any object in the store.&& regardless of position in the tree..&& as discussed in our irmin-pack post.&& the context index was optimised for very fast reads at the cost of needing to perform an expensive maintenance operation at regular intervals. this design was very effective in the early months of the tezos chain.&& but our recent work on benchmarking the storage layer revealed two problems with it:.&& content-addressing bottlenecks transaction throughput. using hashes as object addresses adds overhead to both reads and writes: each read requires consulting the index.&& and each write requires adding a new entry to it. at the current block rate and block size in tezos mainnet.&& these overheads are not a limiting factor.&& but this will change as the protocol and shell become faster. our overall goal is to support a future network throughput of 1000 transactions per second.&& and doing this required rethinking our reliance on the index..&& maintaining a large index impacts the stability of the node. the larger the index becomes.&& the longer it takes to perform regular maintenance operations on it. for sufficiently large contexts (i.e..&& on archive nodes).&& the store may be unable to perform this maintenance quickly enough.&& leading to long pauses as the node waits for service from the storage layer. in the context of tezos.&& this can lead to users occasionally exceeding the maximum time allowed for baking or endorsing a block.&& losing out on the associated rewards..&& over the last few months.&& the storage team at tarides has been hard at work addressing these issues by switching to a minimal indexing strategy in the context. this feature is now ready to ship.&& and we are delighted to present the results!.&& the latest release of irmin ships with a new core feature that enables object addresses that are not hashes. this feature unlocks many future optimisations for the octez context.&& including things like automatic inlining and layered storage. crucially.&& it has allowed us to switch to using direct pointers between internal objects in the octez context.&& eliminating the need to index such objects entirely! this has two immediate benefits:.&& read operations no longer need to search the index.&& improving the overall speed of the storage considerably;.&& the index can be shrunk by a factor of 360 (from 21g to 59mb in our tests!). we now only need to index commit objects in order to be able to recover the root tree for a given block at runtime. this minimal indexing strategy results in indices that fit comfortably in memory and dont need costly maintenance. as of octez 13.&& minimal indexing is now the default node behaviour2..&& so what is the performance impact of this change? as detailed in our recent post on replay benchmarking.&& we were able to isolate and measure the consequences of this change by replaying a previously-recorded trace of chain activity against the newly-improved storage layer. this process simulates a node that is bottlenecked purely by the storage layer.&& allowing us to assess its limits independently of the other components of the shell..&& for these benchmarks.&& we used a replay trace containing the first 150.&&000 blocks of the hangzhou protocol deployment on tezos mainnet (corresponding to the period december 2021 â€“ january 2022)3..&& one of the most important metrics collected by our benchmarks is overall throughput.&& measured in transactions processed per second (tps). in this context.&& a transaction is an individual state transition within a particular block (e.g..&& a balance transfer or a smart contract activation). we queried the tzstats api in order to determine the number of transactions in each block and thus.&& our measured transaction throughput. as shown in the graph above.&& doing this for the last few releases of octez reveals that storage tps has skyrocketted from ~200 in octez 12 to more than 1000 in octez 13! ðŸš€.&& as a direct consequence.&& the total time necessary to replay our hangzhou trace on the storage layer has decreased from ~1 day to ~4 hours. were nearly 6 times faster than before!.&& .&& comparison of cpu time elapsed between octez 10.&& 11.&& 12.&& and 13 while replaying the 150k first blocks of the hangzhou protocol on tezos mainnet1. while octez 10 took 1 day to complete the replay.&& octez 13 only takes 4 hours and is nearly 6 times faster than before!.&& overall throughput is not the only important metric.&& however. its also important that the variance of storage performance is kept to a minimum.&& to ensure that unrelated tasks such as endorsement can be completed promptly. to see the impact of this.&& we can inspect how the total block time varies throughout the replay:.&& .&& comparison of block time latencies between octez 10.&& 11.&& 12.&& and 13 while replaying the 150k first blocks of the hangzhou protocol on tezos mainnet1. octez 13s mean block validation time is 23.2 Â± 2.0 milliseconds while octez v10 was down from 274 Â± 183 milliseconds (and a worst-case peak of 800 milliseconds!). this 12x improvement in opearations mean latency leads to much more consistent endorsement rights for bakers..&& another performance metric that has a big impact on node maintainers is the maximum memory usage of the node.&& since this sets a lower bound on the hardware that can run octez. tezos prides itself on being deployable to very resource-constrained hardware (such as the raspberry pi).&& so this continues to be a focus for us. thanks to the reduced index size.&& octez 13 greatly reduces the memory requirements of the storage layer:.&& .&& comparison of maximal memory usage (as reported by getrusage(2)) between octez 10.&& 11.&& 12.&& and 13 while replaying the 150k first blocks of the hangzhou protocol on tezos mainnet1. the peak memory usage is x5 less in the octez 13 storage layer compared to octez 10**.&& owing to the significantly reduced size of the index. 400 mb of ram is now enough to bootstrap octez 13!.&& finally.&& without an index the context store can no longer guarantee to have perfect object deduplication. our tests and benchmarks show that this choice has relatively little impact on the context size as a whole.&& particularly since it no longer needs to store an index entry for every object!.&& .&& comparison of storage size between octez 10.&& 11.&& 12.&& and 13 while replaying the 150k first blocks of the hangzhou protocol on tezos mainnet1. octez 13s uses similar disk resources than previous versions: the duplicated data is fully compensated by the reduced indexed size..&& what this means for users of the octez shell:.&& irmin 3 is included with octez v13-rc1.&& which has just been released today. the storage format is fully backwards-compatible with octez 12.&& and no migration process is required to upgrade..&& newly-written data after the shell upgrade will automatically benefit from the new.&& direct internal pointers.&& and existing data will continue being read as before. performing a bootstrap (or importing a snapshot) with octez 13 will build a context containing only direct pointers. node operators should upgrade as soon as possible to benefit..&& irmin 3 is just the beginning of what the tarides storage team has in store for 2022. our next focus is on implementing the next iteration of the layered store.&& a garbage collection strategy for rolling nodes. once this has landed.&& we will collaborate with the tarides multicore applications team to help migrate octez to using the newly-merged multicore ocaml..&& if this work sounds interesting.&& the irmin team at tarides is currently hiring!.&& thanks for reading.&& and stay tuned for future updates from the irmin team!][, lightning fast with irmin: tezos storage is 6x faster with 1000 tps surpassed, merkle databases: to index or not to index, consistently fast transactions: surpassing the 1000 tps threshold, migrating your octez node to use the newer storage, the future of the octez storage layer]lightning fast with irmin: tezos storage is 6x faster with 1000 tps surpassed | tarides[supporting one thousand transactions per second, 6x improvement, makes the storage layer orders of magnitude more stable, 12x improvement in the mean latency of operations, reduced the memory usage by 80%, 6x improvement, content-addressing bottlenecks transaction throughput, 1000 transactions per second, maintaining a large index impacts the stability of the node, read operations no longer need to search the index, the index can be shrunk by a factor of 360, 6 times faster, 12x improvement in opearations mean latency, the peak memory usage is x5 less, the general i/o performance of the storage layer is vastly improved, eliminates the risk of losing baking rewards, fully backwards-compatible][open source, services, careers, blog, about us, content-addressing bottlenecks transaction throughput. using hashes as object addresses adds overhead to both reads and writes: each read requires consulting the index, and each write requires adding a new entry to it. at the current block rate and block size in tezos mainnet, these overheads are not a limiting factor, but this will change as the protocol and shell become faster. our overall goal is to support a future network throughput of 1000 transactions per second, and doing this required rethinking our reliance on the index., maintaining a large index impacts the stability of the node. the larger the index becomes, the longer it takes to perform regular maintenance operations on it. for sufficiently large contexts (i.e., on archive nodes), the store may be unable to perform this maintenance quickly enough, leading to long pauses as the node waits for service from the storage layer. in the context of tezos, this can lead to users occasionally exceeding the maximum time allowed for baking or endorsing a block, losing out on the associated rewards., read operations no longer need to search the index, improving the overall speed of the storage considerably;, the index can be shrunk by a factor of 360 (from 21g to 59mb in our tests!). we now only need to index commit objects in order to be able to recover the root tree for a given block at runtime. this minimal indexing strategy results in indices that fit comfortably in memory and dont need costly maintenance. as of octez 13, minimal indexing is now the default node behaviour2., the general i/o performance of the storage layer is vastly improved, as the storage operations are 6 times faster and a have 12 times lower mean latency while the memory usage is divided by 5., in particular, this mode eliminates the risk of losing baking rewards due to long index merges., our benchmarks compare octez 10.2, 11.1, 12.0, and 13.0-rc1 by replaying the 150k first blocks of the hangzhou protocol on tezos mainnet (corresponding to the period dec 2021 â€“ jan 2022) on an intel xeon e-2278g processor constrained to use at most 8 gb ram. our benchmarking setup explicitly excludes the networking i/o operations and protocol computations to focus on the context i/o operations only. octez 10.2 uses irmin 2.7.2, while both octez 11.1 and 12.0 use irmin 2.9.1 (which explains why the graphs are similar). octez v13-rc1 uses irmin 3.2.1, which we just released this month (apr 2022).â†©, the trade-off here is that without an index the context store can no longer guarantee to have perfect deduplication, but our testing and benchmarks indicate that this has relatively little impact on the size of the context as a whole (particularly after accounting for no longer needing to store an index entry for every object!).â†©, to reproduce these benchmarks, you can download the replay trace we used here (14g). this trace can be replayed against a fork of lib_context available here.â†©, open source, services, careers, blog, about us]