[one of the ways that amazon makes online shopping more convenient for customers is by caching the results of popular product queries. if a lot of people are searching for x brand shoes, then amazon’s servers store the results of the query “x brand shoes” and serve them to anyone who types that query, without having to re-execute the product retrieval algorithm and fetch product data from the amazon catalogue., the problem is that if “x brand shoes” is a popular query, then “x brand shoe” probably is, too, and maybe “shoes brand x”, “x brand footwear”, and other variations. if the servers are filling the cache with different ways of describing the same product, then it’s an inefficient use of space., in a paper we presented last week at the web conference, we describe a technique for using cache space more efficiently, by storing only one descriptor of every product. to route syntactically varied but semantically similar queries to that one descriptor, we use a technique called locality-sensitive hashing (lsh)., , to people familiar with the concept of hashing from college computer science courses, lsh can seem counterintuitive. like conventional hashing, lsh involves a hash function that maps an arbitrary string of symbols to a unique location in an array, commonly known as a hash bucket., but unlike conventional hashing, which attempts to distribute strings across buckets randomly and uniformly, lsh tries to map similar symbol strings to the same bucket. where conventional hashing seeks to minimize collisions, or mappings to the same bucket, lsh encourages them., essentially, our idea is to map related product queries to the same bucket, which stores the location of the associated results. the catch is that, like a conventional hash function, a locality-sensitive hash function will sometimes map different strings to the same bucket. “brand x shoes”, “brand x shoe”, and “shoes brand x” might all map to the same bucket, but “brand a jeans” might, too., part of our solution to this problem is to store, in every bucket, one canonical query for each set of related queries that maps to that location. for the family of queries about brand x shoes, for instance, we pick one at random — say, “brand x shoes” — and store that in the associated bucket, as an index to the list of appropriate query results., of course, the same bucket might also contain an index for “brand a jeans”, or an indefinite number of additional indices. if our query — say, “x brand footwear” — maps to a bucket with multiple indices, how do we know which set of results to retrieve?, our answer is to hash the same string multiple times, using slightly different locality-sensitive hash functions. one function might map “x brand footwear” to a bucket that includes “brand x shoes”, “brand a jeans”, and “brand q cameras”; another might map it to a bucket that includes “acme widgets”, “brand x shoes”, and “top-shelf pencils”; and so on. across all these mappings, we simply tally the index that shows up most frequently and retrieve the results associated with it., in practice, we find that 36 different hash functions works well. this reduces the likelihood of retrieving the wrong set of query results to near zero., , to map similar inputs to the same buckets, locality-sensitive hash functions must, of course, encode some notion of similarity. for any standard similarity measure — euclidean distance, l-norm, and so on — it’s possible to construct a locality-sensitive hash function that implements it., for our purposes, we use weighted jaccard similarity. jaccard similarity is the ratio of the number of elements two data items have in common to the total number of elements they contain: it’s the ratio of their intersection to their union., weighted jaccard similarity gives certain correspondences between data items greater weight than others. in our case, we assign weights using a machine learning model trained to do named-entity recognition., the intuition is that customers looking for brand x shoes will be more accepting of query results that include brand y shoes than of results that include brand x t-shirts. so our weighted jaccard measure gives greater weight to product category correspondences than to brand name correspondences. that weighting is all done offline and incorporated into the design of the hash function., , in a second web conference paper, “massive text normalization via an efficient randomized algorithm”, we describe the process we use to identify clusters of related queries — “brand x shoes”, “brand x shoe”, “brand x footwear”, and so on — and select one of them as the index query. (in fact, the paper describes a general procedure for assimilating varied expressions of the same concept to a single, canonical expression. but we adapt it to the problem of caching query results.), once we’ve constructed our family of 36 hash functions, we use them all to hash our complete list of popular product queries. every time two queries are hashed to the same bucket, we increment the weight of the edge that connects them in a huge graph. so by the time we’ve completed the final hash, the maximum edge weight is 36, the minimum 1., then, we delete all the graph edges whose weights fall below some threshold. the result is a host of subgraphs of related terms. from each subgraph, we randomly pick one term as the index for that family of queries., to evaluate our approach, we selected 60 million popular amazon store product queries and divided them into three equal groups, according to frequency: normal queries, hard queries, and long-tail queries. then we used four different techniques to cache the results of those queries in a fixed amount of storage space., we measured performance using f1 score, which combines recall — the fraction of results that the method retrieves from the cache — and precision — the frequency with which the method retrieves the correct query results., compared to exact caching, which uses conventional hashing to map queries to results, the improvements in f1 score afforded by our method ranged from 33%, for the normal queries, to 250%, for the long-tail queries. those improvements did come at the expense of an increase in retrieval time, from 0.1 milliseconds to 2.1 milliseconds. but in many cases, the increase in cache capacity will be worth it.][more-efficient caching for product retrieval, locality-sensitive hashing enables cache to hold more than three times as many query results., conference, related publications, locality-sensitive hashing, similarity functions, concept clusters, conference, related publications, related content, work with us]more-efficient caching for product retrieval - amazon science[][research areas automated reasoning cloud and systems computer vision conversational ai / natural-language processing economics information and knowledge management machine learning operations research and optimization quantum technologies robotics search and information retrieval security, privacy, and abuse prevention sustainability automated reasoning cloud and systems computer vision conversational ai / natural-language processing economics information and knowledge management machine learning operations research and optimization quantum technologies robotics search and information retrieval security, privacy, and abuse prevention sustainability, automated reasoning, cloud and systems, computer vision, conversational ai / natural-language processing, economics, information and knowledge management, machine learning, operations research and optimization, quantum technologies, robotics, search and information retrieval, security, privacy, and abuse prevention, sustainability, automated reasoning, cloud and systems, computer vision, conversational ai / natural-language processing, economics, information and knowledge management, machine learning, operations research and optimization, quantum technologies, robotics, search and information retrieval, security, privacy, and abuse prevention, sustainability, blog, news and features awards and recognitions awards and recognitions, awards and recognitions, awards and recognitions, publications, conferences, collaborations academics at amazon alexa prize amazon research awards academics at amazon alexa prize amazon research awards, academics at amazon, alexa prize, amazon research awards, academics at amazon, alexa prize, amazon research awards, careers internships working at amazon internships working at amazon, internships, working at amazon, internships, working at amazon, twitter, instagram, youtube, facebook, linkedin, research areas automated reasoning cloud and systems computer vision conversational ai / natural-language processing economics information and knowledge management machine learning operations research and optimization quantum technologies robotics search and information retrieval security, privacy, and abuse prevention sustainability automated reasoning cloud and systems computer vision conversational ai / natural-language processing economics information and knowledge management machine learning operations research and optimization quantum technologies robotics search and information retrieval security, privacy, and abuse prevention sustainability, automated reasoning, cloud and systems, computer vision, conversational ai / natural-language processing, economics, information and knowledge management, machine learning, operations research and optimization, quantum technologies, robotics, search and information retrieval, security, privacy, and abuse prevention, sustainability, automated reasoning, cloud and systems, computer vision, conversational ai / natural-language processing, economics, information and knowledge management, machine learning, operations research and optimization, quantum technologies, robotics, search and information retrieval, security, privacy, and abuse prevention, sustainability, blog, news and features awards and recognitions awards and recognitions, awards and recognitions, awards and recognitions, publications, conferences, collaborations academics at amazon alexa prize amazon research awards academics at amazon alexa prize amazon research awards, academics at amazon, alexa prize, amazon research awards, academics at amazon, alexa prize, amazon research awards, careers internships working at amazon internships working at amazon, internships, working at amazon, internships, working at amazon, facebook, twitter, linkedin, email, the web conference 2022, rose: robust caches for amazon product search, massive text normalization via an efficient randomized algorithm, search and information retrieval, hash functions, the web conference, the web conference 2022, rose: robust caches for amazon product search, massive text normalization via an efficient randomized algorithm, applying pecos to product retrieval and text autocompletion daniel n. hill, hsiang-fu yu august 26, 2021 two kdd papers demonstrate the power and flexibility of amazon’s framework for “extreme multilabel ranking”. search and information retrieval, more efficient and reliable retrieval of distributed data matthias petri july 30, 2021 “anytime query” approach adapts to the available resources. search and information retrieval, credit: giana bucchino amazon open-sources library for prediction over large output spaces hsiang-fu yu, inderjit s. dhillon april 28, 2021 framework improves efficiency, accuracy of applications that search for a handful of solutions in a huge space of candidates. machine learning, about, research areas, blog, news and features, publications, conferences, collaborations, careers, alexa prize, academics, research awards, amazon developer, amazon web services, about amazon, newsletter, rss, twitter, instagram, youtube, facebook, linkedin]