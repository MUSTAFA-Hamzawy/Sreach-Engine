[skip to content, tracking change and innovation in the enterprise software development community, en | 中文 | 日本語 | br, version 1.4, infoq, continuous application performance, , defy all challenges. microsoft® visual studio 2008, terracotta: scale your apps w/ease offload the db: learn more!, testing tools to support agile software delivery whitepaper, , , posted by stefan tilkov on jul 02, 2008 09:25 am, when people start trying out rest, they usually start looking around for examples – and not only find a lot of examples that claim to be “restful”, or are labeled as a “rest api”, but also dig up a lot of discussions about why a specific service that claims to do rest actually fails to do so., create rest-enabled web applications, create a photo album application with project zero and rest design principles, introducing ibm websphere smash, part 1: build restful services for your web application, combine the power of websphere smash with adobe flex, powering google gadgets with websphere smash, why does this happen? http is nothing new, but it has been applied in a wide variety of ways. some of them were in line with the ideas the web’s designers had in mind, but many were not. applying rest principles to your http applications, whether you build them for human consumption, for use by another program, or both, means that you do the exact opposite: you try to use the web “correctly”, or if you object to the idea that one is “right” and one is “wrong”: in a restful way. for many, this is indeed a very new approach., the usual standard disclaimer applies: rest, the web, and http are not the same thing; rest could be implemented with many different technologies, and http is just one concrete architecture that happens to follow the rest architectural style. so i should actually be careful to distinguish “rest” from “restful http”. i’m not, so let’s just assume the two are the same for the remainder of this article., as with any new approach, it helps to be aware of some common patterns. in the first two articles of this series, i’ve tried to outline some basic ones – such as the concept of collection resources, the mapping of calculation results to resources in their own right, or the use of syndication to model events. a future article will expand on these and other patterns. for this one, though, i want to focus on anti-patterns – typical examples of attempted restful http usage that create problems and show that someone has attempted, but failed, to adopt rest ideas., let’s start with a quick list of anti-patterns i’ve managed to come up with:, let’s go through each of them in detail., to many people, rest simply means using http to expose some application functionality. the fundamental and most important operation (strictly speaking, “verb” or “method” would be a better term) is an http get. a get should retrieve a representation of a resource identified by a uri, but many, if not all existing http libraries and server programming apis make it extremely easy to view the uri not as a resource identifier, but as a convenient means to encode parameters. this leads to uris like the following:, the characters that make up a uri do not, in fact, tell you anything about the “restfulness” of a given system, but in this particular case, we can guess the get will not be “safe”: the caller will likely be held responsible for the outcome (the deletion of a customer), although the spec says that get is the wrong method to use for such cases., the only thing in favor of this approach is that it’s very easy to program, and trivial to test from a browser – after all, you just need to paste a uri into your address bar, tweak some “parameters”, and off you go. the main problems with this anti-patterns are:, note that apis that follow this anti-pattern might actually end up being accidentally restful. here is an example:, is this a uri that identifies an operation and its parameters, or does it identify a resource? you could argue both cases: this might be a perfectly valid, bookmarkable uri; doing a get on it might be “safe”; it might respond with different formats according to the accept header, and support sophisticated caching. in many cases, this will be unintentional. often, apis start this way, exposing a “read” interface, but when developers start adding “write” functionality, you find out that the illusion breaks (it’s unlikely an update to a customer would occur via a put to this uri – the developer would probably create a new one)., this anti-pattern is very similar to the first one, only that this time, the post http method is used. post carries an entity body, not just a uri. a typical scenario uses a single uri to post to, and varying messages to express differing intents. this is actually what soap 1.1 web services do when http is used as a “transport protocol”: it’s actually the soap message, possibly including some ws-addressing soap headers, that determines what happens., one could argue that tunneling everything through post shares all of the problems of the get variant, it’s just a little harder to use and cannot explore caching (not even accidentally), nor support bookmarking. it actually doesn’t end up violating any rest principles so much – it simply ignores them., even if you use the verbs as they are intended to be used, you can still easily ruin caching opportunities. the easiest way to do so is by simply including a header such as this one in your http response:, doing so will simply prevent caches from caching anything. of course this may be what you intend to do, but more often than not it’s just a default setting that’s specified in your web framework. however, supporting efficient caching and re-validation is one of the key benefits of using restful http. sam ruby suggests that a key question to ask when assessing somethings restfulness is “do you support etags”? (etags are a mechanism introduced in http 1.1 to allow a client to validate whether a cached representation is still valid, by means of a cryptographic checksum). the easiest way to generate correct headers is to delegate this task to a piece of infrastructure that “knows” how to do this correctly – for example, by generating a file in a directory served by a web server such as apache httpd., of course there’s a client side to this, too: when you implement a programmatic client for a restful service, you should actually exploit the caching capabilities that are available, and not unnecessarily retrieve a representation again. for example, the server might have sent the information that the representation is to be considered “fresh” for 600 seconds after a first retrieval (e.g. because a back-end system is polled only every 30 minutes). there is absolutely no point in repeatedly requesting the same information in a shorter period. similarly to the server side of things, going with a proxy cache such as squid on the client side might be a better option than building this logic yourself., caching in http is powerful and complex; for a very good guide, turn to mark nottingham’s cache tutorial., unknown to many web developers, http has a very rich set of application-level status codes for dealing with different scenarios. most of us are familiar with 200 (“ok”), 404 (“not found”), and 500 (“internal server error”). but there are many more, and using them correctly means that clients and servers can communicate on a semantically richer level., for example, a 201 (“created”) response code signals that a new resource has been created, the uri of which can be found in a location header in the response. a 409 (“conflict”) informs the client that there is a conflict, e.g. when a put is used with data based on an older version of a resource. a 412 (“precondition failed”) says that the server couldn’t meet the client’s expectations., another aspect of using status codes correctly affects the client: the status codes in different classes (e.g. all in the 2xx range, all in the 5xx range) are supposed to be treated according to a common overall approach – e.g. a client should treat all 2xx codes as success indicators, even if it hasn’t been coded to handle the specific code that has been returned., many applications that claim to be restful return only 200 or 500, or even 200 only (with a failure text contained in the response body – again, see soap). if you want, you can call this “tunneling errors through status code 200”, but whatever you consider to be the right term: if you don’t exploit the rich application semantics of http’s status codes, you’re missing an opportunity for increased re-use, better interoperability, and looser coupling., using cookies to propagate a key to some server-side session state is another rest anti-pattern., cookies are a sure sign that something is not restful. right? no; not necessarily. one of the key ideas of rest is statelessness – not in the sense that a server can not store any data: it’s fine if there is resource state, or client state. it’s session state that is disallowed due to scalability, reliability and coupling reasons. the most typical use of cookies is to store a key that links to some server-side data structure that is kept in memory. this means that the cookie, which the browser passes along with each request, is used to establish conversational, or session, state., if a cookie is used to store some information, such as an authentication token, that the server can validate without reliance on session state, cookies are perfectly restful – with one caveat: they shouldn’t be used to encode information that can be transferred by other, more standardized means (e.g. in the uri, some standard header or – in rare cases – in the message body). for example, it’s preferable to use http authentication from a restful http point of view., the first rest idea that’s hard to accept is the standard set of methods. rest theory doesn’t specify which methods make up the standard set, it just says there should be a limited set that is applicable to all resources. http fixes them at get, put, post and delete (primarily, at least), and casting all of your application semantics into just these four verbs takes some getting used to. but once you’ve done that, people start using a subset of what actually makes up rest – a sort of web-based crud (create, read, update, delete) architecture. applications that expose this anti-pattern are not really “unrestful” (if there even is such a thing), they just fail to exploit another of rest’s core concepts: hypermedia as the engine of application state., hypermedia, the concept of linking things together, is what makes the web a web – a connected set of resources, where applications move from one state to the next by following links. that might sound a little esoteric, but in fact there are some valid reasons for following this principle., the first indicator of the “forgetting hypermedia” anti-pattern is the absence of links in representations. there is often a recipe for constructing uris on the client side, but the client never follows links because the server simply doesn’t send any. a slightly better variant uses a mixture of uri construction and link following, where links typically represent relations in the underlying data model. but ideally, a client should have to know a single uri only; everything else – individual uris, as well as recipes for constructing them e.g. in case of queries – should be communicated via hypermedia, as links within resource representations. a good example is the atom publishing protocol with its notion of service documents, which offer named elements for each collection within the domain that it describes. finally, the possible state transitions the application can go through should be communicated dynamically, and the client should be able to follow them with as little before-hand knowledge of them as possible. a good example of this is html, which contains enough information for the browser to offer a fully dynamic interface to the user., i considered adding “human readable uris” as another anti-pattern. i did not, because i like readable and “hackable” uris as much as anybody. but when someone starts with rest, they often waste endless hours in discussions about the “correct” uri design, but totally forget the hypermedia aspect. so my advice would be to limit the time you spend on finding the perfect uri design (after all, their just strings), and invest some of that energy into finding good places to provide links within your representations., http’s notion of content negotiation allows a client to retrieve different representations of resources based on its needs. for example, a resource might have a representation in different formats such as xml, json, or yaml, for consumption by consumers implemented in java, javascript, and ruby respectively. or there might be a “machine-readable” format such as xml in addition to a pdf or jpeg version for humans. or it might support both the v1.1 and the v1.2 versions of some custom representation format. in any case, while there may be good reasons for having one representation format only, it’s often an indication of another missed opportunity., it’s probably obvious that the more unforeseen clients are able to (re-)use a service, the better. for this reason, it’s much better to rely on existing, pre-defined, widely-known formats than to invent proprietary ones – an argument that leads to the last anti-pattern addressed in this article., this anti-pattern is so common that it’s visible in almost every rest application, even in those created by those who call themselves “restafarians” – myself included: breaking the constraint of self-descriptiveness (which is an ideal that has less to do with ai science fiction than one might think at first glance). ideally, a message – an http request or http response, including headers and the body – should contain enough information for any generic client, server or intermediary to be able to process it. for example, when your browser retrieves some protected resource’s pdf representation, you can see how all of the existing agreements in terms of standards kick in: some http authentication exchange takes place, there might be some caching and/or revalidation, the content-type header sent by the server (“application/pdf”) triggers the startup of the pdf viewer registered on your system, and finally you can read the pdf on your screen. any other user in the world could use his or her own infrastructure to perform the same request. if the server developer adds another content type, any of the server’s clients (or service’s consumers) just need to make sure they have the appropriate viewer installed., every time you invent your own headers, formats, or protocols you break the self-descriptiveness constraint to a certain degree. if you want to take an extreme position, anything not being standardized by an official standards body breaks this constraint, and can be considered a case of this anti-pattern. in practice, you strive for following standards as much as possible, and accept that some convention might only apply in a smaller domain (e.g. your service and the clients specifically developed against it)., ever since the “gang of four” published their book, which kick-started the patterns movement, many people misunderstood it and tried to apply as many patterns as possible – a notion that has been ridiculed for equally as long. patterns should be applied if, and only if, they match the context. similarly, one could religiously try to avoid all of the anti-patterns in any given domain. in many cases, there are good reasons for violating any rule, or in rest terminology: relax any particular constraint. it’s fine to do so – but it’s useful to be aware of the fact, and then make a more informed decision., hopefully, this article helps you to avoid some of the most common pitfalls when starting your first rest projects., many thanks to javier botana and burkhard neppert for feedback on a draft of this article., stefan tilkov is the lead editor of infoq’s soa community and co-founder, principal consultant and lead restafarian of germany/switzerland-based innoq., sponsored by, see all on soa social website, how will the recession affect your soa project plans?, view all results, have something to say? cast your vote!, reply, back to top, jul 1, 2008 2:01 pm by ray krueger, i think this probably ties into your "tunneling through get" point. i've seen a few applications with interfaces like this..., , reply, back to top, jul 1, 2008 4:10 pm by colin jack, really good stuff, i've been reading a lot about rest recently and this is exactly the sort of content that is needed for people like me who are only now looking into the topic in detail. in fact its so good that i think it would be useful if (at some point) there were further articles that could go into detail on some of the aspects you cover, in particular "breaking self-descriptiveness" and "forgetting hypermedia". personally i found that initially these aspects of rest were initially difficult to grasp. i was also wondering whether you were aware of an existing rest reference application, particular one that covers an enterprise application?, reply, back to top, jul 1, 2008 4:15 pm by stefan tilkov, thanks colin. the only attempt at an enterprise application reference implementation is joe gregorio's rest daytrader variant. any suggestion what other enterprise app could be used as an example would be greatly appreciated., reply, back to top, jul 1, 2008 10:55 pm by karl krukow, hello stefan, <p> thanks for another great article — i am looking forward to the future ones that will go more in depth. <p> i was wondering about two of your points: <p> point 5. “misusing cookies” - as you mention, the usual way of performing authentication in web applications is to assign a session id to each fresh request, keep this as a cookie and then store session information at the server which says, e.g., the session id is authenticated and corresponds to user x. you seem to argue that the restful approach would be to avoid this and use e.g. http basic or digest authentication, is this correct? at first thought this seems impractical… what would you say? in practice what would you do for your ‘common-case ajax web-app’? <p> point 6. hypermedia. i like this principle, but i’m wondering about the consequences of taking this approach to the extreme. often you want composite or ‘aggregate’ representation of resources. for example, a user might have a userprofile and account information, etc. if you want a representation of this user, say in a web-app, you often want a page composing username (a property of the user resource) with adress (say userprofile) and account number (account resource information). you can fetch the user resource which links to it’s user profile which may in turn link to the account. in this approach, being rest compliant entails many more http request than a single aggregate i.e., non-hypermedia based approach. <p> in general suppose you want a summary view of a collection resource. you can represent your collection as a list of links to the individual resources, or you can aggregate the collection to one large response. if you do the former, you potentially have n requests where a single would be enough. it reminds me of the n+1 problem for databases... of course you may argue the other way around, but the discussion is still valid. <p> what is your opinion on this? it it better to create a new aggregate resource specifically for this purpose? <p> thanks, — karl</p></p></p></p></p></p></p>, reply, back to top, jul 2, 2008 12:39 am by stefan tilkov, thanks karl. adressing your first point: wherever possible, i would indeed suggest using http authentication instead of cookies. but even if you use cookies, it's perfectly fine to do so if you avoid session state. the way to do this is to encode a token, in the cookie that the server can validate without session state. aristotle pagaltzis recently summarized how to do this in a discussion in the yahoo! rest-discuss group: regarding your second point: if i understand you correctly, you want to use aggregate resources. this is fine, and i don't see a conflict with hypermedia. on the contrary, you can actually include links to the details view and back, offering your users to navigate into the direction that's more appropriate for them., , reply, back to top, jul 2, 2008 3:06 am by bryan taylor, regarding tunneling through post, you wrote "it actually doesn’t end up violating any rest principles so much – it simply ignores them." this is interesting, and it echos a point i've made: if i do soap and i as the service designer i'm not able or willing to declare any of my operations permanently "safe", then the http spec tells me i should use post, and i'm not certainly not violating any principle of rest. i'd certainly agree it's not in the "spirit" of rest, which wants me to introduce safe resources for most of my "nouns", but does soap violate any objective principle of rest? i think it's just not idiomatic, but at this point it's not an objective, technical criteria but a subjective, artistic one. when discussing the gof patterns, i don't think there's much artistic interpretation that goes on to know if i have a factory pattern, strategy pattern, command pattern, or whatever. does rest boil down to "i know it when i see it". if i look at soap as a way to send a message to a method of a some kind of virtual object ("simple object access protocol", after all), the fact that object behavior is encapsulated means that i, as the web service builder and a client of underlying class, don't know if the method is safe or not because it doesn't tell me that it is. it could be getpurchaseorder(), but i really don't know if this is an idempotent operation. often it is, but i can't guarantee that it is without some kind of language semantics like some kind of @safe annotation (which doesn't exist to my knowledge). absent something like this, isn't post the only reasonable thing to use? even if i know the base implementation class uses a safe implementation, a runtime instance could polymorph this safe behavior into something that's not safe, right? anyway, it seems that the real idiomatic difference is between rest and oo, not just rest and soap. i'd like to understand what it is about the web that makes rest a "nicer" programming paradigm than oo. conversely, why not apply rest everywhere, like say in the programming language itself. imagine that object declares get(), put(), post(), and delete() and is final. imagine a uri scheme object:// instead of references. would anybody use this language? it'd certainly simplify my javadocs :), reply, back to top, jul 2, 2008 4:14 am by jakub nešetřil, congratulations stefan to a nice article. a lot of the patterns are really notorious - however, the one i find most frequented seems to be missing. in my opinion, the real challenge is getting rid of the method-oriented afterthoughts of soap and rmi. in a certain way, rmi is compatible with anybody's programming style, just putting a network between the method invocations. with rest where action is a result of state changes, you have to convince your colleagues to a mental paradigm shift to state-automatons or data-flow programming. that's the part i find really hard., reply, back to top, jul 2, 2008 4:34 am by paul beckford, , , reply, back to top, jul 2, 2008 10:47 am by mani doraisamy, thanks for another great article, stefan. quick question on ignoring status codes: "for example, a 201 (“created”) response code signals that a new resource has been created, the uri of which can be found in a location header in the response." does this mean there has to be 2 requests: one to create and the other to read the content from the uri? is this a feasible option for human consumption?, reply, back to top, jul 2, 2008 11:31 am by alexander klimetschek, , , reply, back to top, jul 2, 2008 11:47 am by craig mcclanahan, , , reply, back to top, jul 2, 2008 12:21 pm by eric larson, one pattern i've seem people follow is using query string parameters when the resource is exposing some sort of algorithm or dynamic representation. the thing to watch out for is that you do not define this pattern in terms of the algorithm or code producing the page, but rather the meaning to the user. for example, adding a "page=3" argument to something like a feed makes sense because you are asking for a slightly different representation of the resource. but, if you have a set of parameters describing the feed such as "tag=java" and "year=2008" then there is a good chance you are exposing an algorithm that would be better served as a simple resource., reply, back to top, jul 2, 2008 2:23 pm by erik johnson, the extreme case of tunneling via post through a single uri certainly has limited appeal. for one thing, it precludes the use of hypermedia links in content (they would all point to same url). that said, i don't see tunneling through post as an automatic anti-pattern. for one thing, given the presence of an otherwise complete uri-space (with the requisite get/put/etc. support), post provides a way to multiplex operations. it isn't feasible to identify each potentially unique content-set and there are times when one round-trip is preferred :). i just don't want to see post==bad become a conclusion without more thought put into it., reply, back to top, jul 3, 2008 2:03 am by mani doraisamy, not sure if i explained the question correctly. i am talking about a usecase where the user hits a create button (for a new purchaseorder) and expects the browser to show up the created resource (i.e. purchaseorder). how would this usecase translate into rest calls?, reply, back to top, jul 3, 2008 5:49 am by stefan tilkov, unfortunately, browsers don't follow the "location" header sent back with a 201 (i don't really have any idea why). to avoid re-submitting, common practice is to send a redirect to the new resource after post, which will make the browser issue a get to it., reply, back to top, jul 3, 2008 10:57 am by mani doraisamy, i assume that redirection means 2 requests from browser: 1) create (or any action) request - as post 2) redirection request to get the resource - as get. while most of the mvc frameworks will return the view after the action in a single request. is this the cost we have to pay for a cleaner architecture? or is there a better way?, reply, back to top, jul 3, 2008 1:20 pm by bryan taylor, when you say "tunneling via post through a single uri certainly has limited appeal", i ask appeal to who? certainly there are a lot of enterprises deploying soap on a large scale that do exactly that. if you had said it's not idiomatic for rest, then certainly you'd be right. i just wonder whether or not embedded uris and the concept of "hypermedia as the engine of application state" is really a human usability thing. if the consumer is code, i don't see any particular benefit. if you have account_id="123" embedded vs an actual account uri the client can actually use this in a more flexible way, where it and not the server decides where it wants to go next. doesn't hateoas actually increase the burden on the server to completely define the workflows that use it's resources as state transitions it supports via links? i'm not saying that is good or bad, just that it is a constraint that many systems, especially in enterprise settings will not be capable of conforming to. i have no doubt that when you can meet that constraint, i do see many benefits that will flow from it., reply, back to top, jul 3, 2008 5:22 pm by paul beckford, hi bryan, maybe i was too subtle in my last response, but rest actively avoids rpc (soap) since it encodes application specific behaviour (operations) in the connector interface itself. this means that each time the behaviour of your server changes so does the interface and hence all clients must change too. this approach is brittle causing you to recompile your client with new a new stub. with a uniform connector and a self describing resource with hyperlinks, then you can represent application state as additional resources which are accessible through links. you can add or delete links as you like exposing and hiding state without braking the uniform connector interface. in roy fieldings dissertation he goes through a number of client server architectural styles and lists the pros and cons for each. if high dependency between client and server is not a problem then an alternative to rest (like rpc) may be your best bet. the success of the web is that it avoids such coupling which means that it can evolve and change without ever needing to recompile the client (browser). this is where rest excels., reply, back to top, jul 6, 2008 12:02 pm by stefan tilkov, , , reply, back to top, jul 7, 2008 6:30 am by james strachan, awesome article stefan - you've definitely nailed most of the anti-patterns folks tend to hit in my experience. rest is definitely one of those things some folks think they are being restful because they use some get and maybe some post - articles like this really help to clarify things. the only other grey areas of rest i've seen that are not mentioned (but are kinda tiny nits really) are... * no easy way to associate xsds with mime types for xml representations - there seems to be a few different ways folks try this hacking the mime type for example. we could maybe do with some kinda standardised way to associate metadata more easily; maybe the atompub service document idea or something wadlish. though given json tends to be easier than xml - maybe this isn't such a biggie :) * using uris instead of accept content-type headers to influence the representation. most good frameworks tend to have a convention where you can, say, append ".xml" or ".json" or ".yaml" or whatever to force the representation without having to specify accept headers. while a bit of a hack it is kinda handy allowing folks to use any browser to view different representations - without relying on custom plugins in browsers etc. it might be nice to kinda standardise this kinda stuff. but those are tiny nits - these 10 anti-patterns are right on the money! keep it up! :), reply, back to top, jul 8, 2008 7:01 am by benjamin carlyle, <p>i was mulling over the phrase "rest patterns" as it was coming up as a training need in my office. i'm focusing on patterns for machine-to-machine communication, but have started to collect a few myself: rest patterns @ soundadvice.id.au</p> <p>i have quite a bit more work to do, and i still have to clear up some cloudy ip issues before i am able to get out my complete list :-/</p>, reply, back to top, jul 9, 2008 1:28 am by bryan taylor, soap uses a rich (non-uniform) interface, because that's what you do when you program with objects, and soap tries to mimick this. so you're argument for the uniform interface is really one against object oriented programming generally, as you haven't told me any web specific reason to necessitate the switch of architectural style. somehow i don't think object oriented coding would be as popular and successful if it was as brittle as you say something without the uniform interface must be. <p/> i also have to question the idea that restful resources are normally "self describing". in fact, this is a key weakness of rest that presently prevents widespread adoption of in enterprise settings (at least until wadl or wsdl 2.0 gain more traction there). the idea that you won't have to redeploy a new client if the server behavior changes in rest is a bit far fetched for the same reason. the fact that hypermedia has embedded uris doesn't mean that client code knows how to translate these uri into a semantic meaning, nor does it protect the client from having to be changed if new state transitions are added or others are taken away. application code must understand the interchange format in detail. rest gives you no way to say anything more descriptive than the media-type such as "application/xml". when i do a get, i may discover that i don't understand the payload or that it's changed from what my client code supports. the wonderful state machine via links is then useless to me. without service descriptions, such changes happen without warning at runtime and break things, even if i got to the /account/1234 doc by following hateous navigations. moreover, if i'm a client constructing a post or a put, i don't even have the benefit of an example. i have no way to know what the payload i should construct must look like, other than xml. <p/>, reply, back to top, jul 10, 2008 8:29 am by benjamin carlyle, <p>brian, </p> <p>it is probably best to avoid emotive words like "rich" when comparing rest to the classical o-o style. a fairer comparison might be "unconstrained" (oo) vs uniform (rest). </p> <p>rest and o-o are closely related. they are both typically client/server request/response messaging paradigms. the client has a reference to the server, and sends it a message. rest is a constrained form of o-o for systems with appreciable network latency, bandwidth constraints, a number of different owners and different release cycles for different components of the architecture. </p> <p>perhaps the clearest contrast is between rest and a strongly-typed o-o language. in nice, crinkly java i get a compile error whenever two components disagree on the definition of an interface. the client tries to call method foo. there is no method foo. bail. in this setting it makes sense to leverage the strongly-typed nature of the language to make sure you don't release junk. you define interfaces in a detailed and domain-specific way that is checked to yield a consistent releasable whole. </p> <p>in rest, i want the client or the server i deployed literally 10 years ago to work with whatever i am putting out today. i also want whatever i'm putting out today to work with every bit of code written since that time, and every bit of code that will be written in the next 10 years. getting more specific than necessary is a sub-optimal approach in this environment. there is no compiler to lean on to ensure consistency, and there is no way you could "fix" the old deployed code to work with your latest and greatest. instead, we lean less on checking and more on uniformity. you don't want to call out thirty or forty versions of an interface that you adapted as your needs changed, and provide explicit support for each. you want something generic, stable and slightly sloppy. </p> <p>it's not a matter of rest rejecting o-o, or for that matter replacing o-o. it's a matter of different contexts. the growing importance of rest is a recognition that the important bit of software architecture is moving away from "how do i get a release of my project out" to "how do i get my system to work with the other 15 business systems either deployed or in the process of being deployed? how do i future-proof this system in face of constant change?"</p> <p>to answer your points: yes, we need better descriptions of what specific urls are going to do with our put and get requests. whether that is a matter of producing more machine-readable content or simply more human-readable content is still up for grabs. yes, we need better document types... the kinds of document types you only come up with by solving real problems. no, i don't think the rest community is at the tipping point where they are solving these problems well enough. i'm hoping they'll/we'll be there soon. at least we know that document-oriented soa is in the same boat with some of our problems.</p> <p>see also my get pattern description. i welcome feedback on this and other pattern descriptions.</p> <p>benjamin.</p>, reply, back to top, jul 13, 2008 6:04 pm by markus krüger, , , reply, back to top, jul 24, 2008 6:53 am by sebastian kirsch, , , reply, back to top, jul 24, 2008 2:10 pm by martin sarsale, first of all, great article. your checklist works pretty good against my api implementation, but i was missing hyperlinking, which makes a lot of sense. this is a more open question, which maybe fits better in a forum. anyway, here it goes: i'm kind of puzzled on how to expose "ephimeral" resources, for example, the output of a search. i understand the search results are 'a resource' but i'm wondering if there's any rule to create urls for those. for example, api.foo.com/search/foo+bar/ and, what happens with paginated searches. do you like this: api.foo.com/search/foo+bar/1 i would love to use "content-range" but i think it's forcing things a little bit :) anyway, really enjoyed the article., reply, back to top, aug 11, 2008 3:45 pm by colin jack, thanks for the link, really good content. i'll try to think of a good example but this one gave me a lot of good information., reply, back to top, sep 3, 2008 8:55 am by matthias wauer, , , reply, back to top, sep 3, 2008 4:47 pm by colin jack, stefan, i think the travel agency service from ch10 in "restful web services" would be a good example. i actually think the authors missed a trick not exploring the travel agency application in more detail. not to say social bookmarking examples aren't interesting but really i think most examples of services that "have a different grain than the rest of the web" would be useful., reply, back to top, sep 21, 2008 11:41 am by eike herzbach, here help.launchpad.net/api it says:, , reply, back to top, oct 24, 2008 12:29 am by stefan tilkov, without having taken a closer look, this seems to show either a misunderstanding of rest or unwillingness to label things correctly :-) it seems like a classical example of post tunneling., reply, back to top, oct 24, 2008 9:00 am by alex popescu, , , reply, back to top, oct 24, 2008 9:02 am by alex popescu, it looks like markus is agreeing with my point in the next comment :-). ./alex, reply, , when time to release is critical, naked objects allows you to quickly generate a presentation layer from annotated domain objects., , christian weyer explains how to create distributed systems using soap or rest on top of windows communication foundation (wcf) or windows workflow foundation (wwf)., , after a brief introduction on cloud computing, matthieu hug, ceo of runmyprocess.com provides his insight on the architecture of multi-enterprise information systems., , when performance and speed are not an issue, smtp and pop3 can be used to integrate applications communicating to each other through a mail server., , in a new article, subbu allamaraju explains how to describe a restful api, focusing on using hypermedia instead of an out-of-band description format such as wadl or wsdl 2.0., , ian wilkes describes the architecture used by the popular game named second life at its debut and how it evolved over years as users and features have been added., , the main takeway points and lessons learned from qcon san francisco 2008 as seen by the many attendees who blogged about qcon. experience qcon through the opinions of the attendees!, , ian flint tries to explain the infrastructure and architecture employed by yahoo! to keep going a multitude of servers running of different platforms and offering different services., infoq.com and all content copyright © 2006-2009 c4media inc. infoq.com hosted at contegix, the best isp we've ever worked with. privacy policy][infoq, your communities, featured topics, sponsored links, article, rest anti-patterns, relatedvendorcontent, related sponsor, tunneling everything through get, tunneling everything through post, ignoring caching, ignoring status codes, misusing cookies, forgetting hypermedia, ignoring mime types, breaking self-descriptiveness, summary, 33 comments, educational content, rapid application development using naked objects for .net, services & workflows: soap and rest with wcf and wwf, will cloud-based multi-enterprise information systems replace extranets?, application integration through mail servers, describing restful applications, second life’s architecture, key takeaway points and lessons learned from qcon san francisco 2008, ian flint explains yahoo! communities architectures]infoq: rest anti-patterns[oct, jan, 2010, stefan tilkov, ray krueger, colin jack, stefan tilkov, karl krukow, stefan tilkov, bryan taylor, jakub nešetřil, paul beckford, mani doraisamy, alexander klimetschek, craig mcclanahan, eric larson, erik johnson, mani doraisamy, stefan tilkov, mani doraisamy, bryan taylor, paul beckford, stefan tilkov, james strachan, benjamin carlyle, bryan taylor, benjamin carlyle, markus krüger, sebastian kirsch, martin sarsale, colin jack, matthias wauer, colin jack, eike herzbach, stefan tilkov, alex popescu, alex popescu][register, login, about us, personal feed, home, java, .net, ruby, soa, agile, architecture, rest & web architecture, , ria/ajax, , performance & scalability, , team collaboration, , soa governance, , print, tunneling everything through get, tunneling everything through post, ignoring caching, ignoring response codes, misusing cookies, forgetting hypermedia, ignoring mime types, breaking self-descriptiveness, resources are not identified by uris; rather, uris are used to encode operations and their parameters, the http method does not necessarily match the semantics, such links are usually not intended to be bookmarked, there is a risk that “crawlers” (e.g. from search engines such as google) cause unintended side effects, thomas erl announced a new community site dedicated to soa patterns. posted today in architects, herbjorn wilhelmsen wrote the article: the case for single-purpose services posted today in architects, a white paper disclosing the top four worst practices for soa integration was published. posted today in architects, stefan besling explained how to build better phone apps with soa and eclipse. posted today in architects, kanu tripathi discussed message auditing in service-oriented architecture. posted today in architects, how will the recession affect your soa project plans? recession will not affect our soa project plans. 0% we will use soa to reduce costs. 100% view all results have something to say? cast your vote!, back to top great points; here's another... jul 1, 2008 2:01 pm by ray krueger i think this probably ties into your "tunneling through get" point. i've seen a few applications with interfaces like this... example.com/somenoun?xml={url encoded xml goes here} and example.com/someothernoun?json={url encoded json goes here} it seems akin to "tunneling messaging through get"... reply, back to top great stuff, be good to read more jul 1, 2008 4:10 pm by colin jack really good stuff, i've been reading a lot about rest recently and this is exactly the sort of content that is needed for people like me who are only now looking into the topic in detail. in fact its so good that i think it would be useful if (at some point) there were further articles that could go into detail on some of the aspects you cover, in particular "breaking self-descriptiveness" and "forgetting hypermedia". personally i found that initially these aspects of rest were initially difficult to grasp. i was also wondering whether you were aware of an existing rest reference application, particular one that covers an enterprise application? reply, back to top re: great stuff, be good to read more jul 1, 2008 4:15 pm by stefan tilkov thanks colin. the only attempt at an enterprise application reference implementation is joe gregorio's rest daytrader variant. any suggestion what other enterprise app could be used as an example would be greatly appreciated. reply, back to top can you expand a bit? jul 1, 2008 10:55 pm by karl krukow hello stefan, <p> thanks for another great article — i am looking forward to the future ones that will go more in depth. <p> i was wondering about two of your points: <p> point 5. “misusing cookies” - as you mention, the usual way of performing authentication in web applications is to assign a session id to each fresh request, keep this as a cookie and then store session information at the server which says, e.g., the session id is authenticated and corresponds to user x. you seem to argue that the restful approach would be to avoid this and use e.g. http basic or digest authentication, is this correct? at first thought this seems impractical… what would you say? in practice what would you do for your ‘common-case ajax web-app’? <p> point 6. hypermedia. i like this principle, but i’m wondering about the consequences of taking this approach to the extreme. often you want composite or ‘aggregate’ representation of resources. for example, a user might have a userprofile and account information, etc. if you want a representation of this user, say in a web-app, you often want a page composing username (a property of the user resource) with adress (say userprofile) and account number (account resource information). you can fetch the user resource which links to it’s user profile which may in turn link to the account. in this approach, being rest compliant entails many more http request than a single aggregate i.e., non-hypermedia based approach. <p> in general suppose you want a summary view of a collection resource. you can represent your collection as a list of links to the individual resources, or you can aggregate the collection to one large response. if you do the former, you potentially have n requests where a single would be enough. it reminds me of the n+1 problem for databases... of course you may argue the other way around, but the discussion is still valid. <p> what is your opinion on this? it it better to create a new aggregate resource specifically for this purpose? <p> thanks, — karl</p></p></p></p></p></p></p> reply, back to top re: can you expand a bit? jul 2, 2008 12:39 am by stefan tilkov thanks karl. adressing your first point: wherever possible, i would indeed suggest using http authentication instead of cookies. but even if you use cookies, it's perfectly fine to do so if you avoid session state. the way to do this is to encode a token, in the cookie that the server can validate without session state. aristotle pagaltzis recently summarized how to do this in a discussion in the yahoo! rest-discuss group: regarding your second point: if i understand you correctly, you want to use aggregate resources. this is fine, and i don't see a conflict with hypermedia. on the contrary, you can actually include links to the details view and back, offering your users to navigate into the direction that's more appropriate for them. auth_token = concat( username, ":", expiration_datetime ); msghash = digest_hmac( concat( server_secret, ":", auth_token ) ); cookie = concat( msghash, ":", auth_token ); rails 2.1 uses a similar approach, but encodes "session" state (which is really client state) in the cookie – a practice i don't really like that much, but would claim is restful nonetheless. reply, back to top tunneling through post jul 2, 2008 3:06 am by bryan taylor regarding tunneling through post, you wrote "it actually doesn’t end up violating any rest principles so much – it simply ignores them." this is interesting, and it echos a point i've made: if i do soap and i as the service designer i'm not able or willing to declare any of my operations permanently "safe", then the http spec tells me i should use post, and i'm not certainly not violating any principle of rest. i'd certainly agree it's not in the "spirit" of rest, which wants me to introduce safe resources for most of my "nouns", but does soap violate any objective principle of rest? i think it's just not idiomatic, but at this point it's not an objective, technical criteria but a subjective, artistic one. when discussing the gof patterns, i don't think there's much artistic interpretation that goes on to know if i have a factory pattern, strategy pattern, command pattern, or whatever. does rest boil down to "i know it when i see it". if i look at soap as a way to send a message to a method of a some kind of virtual object ("simple object access protocol", after all), the fact that object behavior is encapsulated means that i, as the web service builder and a client of underlying class, don't know if the method is safe or not because it doesn't tell me that it is. it could be getpurchaseorder(), but i really don't know if this is an idempotent operation. often it is, but i can't guarantee that it is without some kind of language semantics like some kind of @safe annotation (which doesn't exist to my knowledge). absent something like this, isn't post the only reasonable thing to use? even if i know the base implementation class uses a safe implementation, a runtime instance could polymorph this safe behavior into something that's not safe, right? anyway, it seems that the real idiomatic difference is between rest and oo, not just rest and soap. i'd like to understand what it is about the web that makes rest a "nicer" programming paradigm than oo. conversely, why not apply rest everywhere, like say in the programming language itself. imagine that object declares get(), put(), post(), and delete() and is final. imagine a uri scheme object:// instead of references. would anybody use this language? it'd certainly simplify my javadocs :) reply, back to top the real challenge is letting go of services/methods jul 2, 2008 4:14 am by jakub nešetřil congratulations stefan to a nice article. a lot of the patterns are really notorious - however, the one i find most frequented seems to be missing. in my opinion, the real challenge is getting rid of the method-oriented afterthoughts of soap and rmi. in a certain way, rmi is compatible with anybody's programming style, just putting a network between the method invocations. with rest where action is a result of state changes, you have to convince your colleagues to a mental paradigm shift to state-automatons or data-flow programming. that's the part i find really hard. reply, back to top re: tunneling through post jul 2, 2008 4:34 am by paul beckford anyway, it seems that the real idiomatic difference is between rest and oo, not just rest and soap. i use to think this, but it is another misconception. rest and true (late-bound) oo are very similar in fact. think of the rest uniform connector idea as an object with a fixed protocol (fixed number of methods), and resources as parameters to those methods. using a "uniform connector" means that the client needs to know very little about the server (other than the server understands the uniform protocol). you can use the same technique with objects if you wished (no need for final though), with the same effect of reduced coupling between the client and the server. rest is a response to the problem of large scale application distribution. if i control both client and server in the same memory space then the constraint of a fixed uniform connector is no longer as appealing :) paul. reply, back to top question on "ignoring status codes" jul 2, 2008 10:47 am by mani doraisamy thanks for another great article, stefan. quick question on ignoring status codes: "for example, a 201 (“created”) response code signals that a new resource has been created, the uri of which can be found in a location header in the response." does this mean there has to be 2 requests: one to create and the other to read the content from the uri? is this a feasible option for human consumption? reply, back to top re: question on jul 2, 2008 11:31 am by alexander klimetschek does this mean there has to be 2 requests: one to create and the other to read the content from the uri? is this a feasible option for human consumption? 201 created is (mostly) used after a put to create a new resource. the target url is typically a generic one (eg. /blogposts or /blogposts/*), since often the server builds the unique url for the resource. the 201 confirms the creation and gives the client the information where the new resource can be found now. reply, back to top re: question on "ignoring status codes" jul 2, 2008 11:47 am by craig mcclanahan does this mean there has to be 2 requests expanding a bit on alexander's response, this does not mean two requests. on the response to the "create" request, you return both the 201 "created" status code, and an http "location:" header, whose value should be an absolute url to the newly created resource. reply, back to top exposing algorithms jul 2, 2008 12:21 pm by eric larson one pattern i've seem people follow is using query string parameters when the resource is exposing some sort of algorithm or dynamic representation. the thing to watch out for is that you do not define this pattern in terms of the algorithm or code producing the page, but rather the meaning to the user. for example, adding a "page=3" argument to something like a feed makes sense because you are asking for a slightly different representation of the resource. but, if you have a set of parameters describing the feed such as "tag=java" and "year=2008" then there is a good chance you are exposing an algorithm that would be better served as a simple resource. reply, back to top re: tunneling through post jul 2, 2008 2:23 pm by erik johnson the extreme case of tunneling via post through a single uri certainly has limited appeal. for one thing, it precludes the use of hypermedia links in content (they would all point to same url). that said, i don't see tunneling through post as an automatic anti-pattern. for one thing, given the presence of an otherwise complete uri-space (with the requisite get/put/etc. support), post provides a way to multiplex operations. it isn't feasible to identify each potentially unique content-set and there are times when one round-trip is preferred :). i just don't want to see post==bad become a conclusion without more thought put into it. reply, back to top re: question on "ignoring status codes" jul 3, 2008 2:03 am by mani doraisamy not sure if i explained the question correctly. i am talking about a usecase where the user hits a create button (for a new purchaseorder) and expects the browser to show up the created resource (i.e. purchaseorder). how would this usecase translate into rest calls? reply, back to top re: question on "ignoring status codes" jul 3, 2008 5:49 am by stefan tilkov unfortunately, browsers don't follow the "location" header sent back with a 201 (i don't really have any idea why). to avoid re-submitting, common practice is to send a redirect to the new resource after post, which will make the browser issue a get to it. reply, back to top re: question on "ignoring status codes" jul 3, 2008 10:57 am by mani doraisamy i assume that redirection means 2 requests from browser: 1) create (or any action) request - as post 2) redirection request to get the resource - as get. while most of the mvc frameworks will return the view after the action in a single request. is this the cost we have to pay for a cleaner architecture? or is there a better way? reply, back to top re: tunneling through post jul 3, 2008 1:20 pm by bryan taylor when you say "tunneling via post through a single uri certainly has limited appeal", i ask appeal to who? certainly there are a lot of enterprises deploying soap on a large scale that do exactly that. if you had said it's not idiomatic for rest, then certainly you'd be right. i just wonder whether or not embedded uris and the concept of "hypermedia as the engine of application state" is really a human usability thing. if the consumer is code, i don't see any particular benefit. if you have account_id="123" embedded vs an actual account uri the client can actually use this in a more flexible way, where it and not the server decides where it wants to go next. doesn't hateoas actually increase the burden on the server to completely define the workflows that use it's resources as state transitions it supports via links? i'm not saying that is good or bad, just that it is a constraint that many systems, especially in enterprise settings will not be capable of conforming to. i have no doubt that when you can meet that constraint, i do see many benefits that will flow from it. reply, back to top re: tunneling through post jul 3, 2008 5:22 pm by paul beckford hi bryan, maybe i was too subtle in my last response, but rest actively avoids rpc (soap) since it encodes application specific behaviour (operations) in the connector interface itself. this means that each time the behaviour of your server changes so does the interface and hence all clients must change too. this approach is brittle causing you to recompile your client with new a new stub. with a uniform connector and a self describing resource with hyperlinks, then you can represent application state as additional resources which are accessible through links. you can add or delete links as you like exposing and hiding state without braking the uniform connector interface. in roy fieldings dissertation he goes through a number of client server architectural styles and lists the pros and cons for each. if high dependency between client and server is not a problem then an alternative to rest (like rpc) may be your best bet. the success of the web is that it avoids such coupling which means that it can evolve and change without ever needing to recompile the client (browser). this is where rest excels. reply, back to top re: question on jul 6, 2008 12:02 pm by stefan tilkov i assume that redirection means 2 requests from browser: 1) create (or any action) request - as post 2) redirection request to get the resource - as get. there is no reason at all a framework would have to do all actions via post, so in many cases, a single request is fine. when a post is used, there should be a redirect simply to avoid the warning when a user hits "refresh", and to support bookmarking. things would be much better if browsers supported put and delete and followed location headers in 201 responses - but sadly, they don't. reply, back to top great stuff! jul 7, 2008 6:30 am by james strachan awesome article stefan - you've definitely nailed most of the anti-patterns folks tend to hit in my experience. rest is definitely one of those things some folks think they are being restful because they use some get and maybe some post - articles like this really help to clarify things. the only other grey areas of rest i've seen that are not mentioned (but are kinda tiny nits really) are... * no easy way to associate xsds with mime types for xml representations - there seems to be a few different ways folks try this hacking the mime type for example. we could maybe do with some kinda standardised way to associate metadata more easily; maybe the atompub service document idea or something wadlish. though given json tends to be easier than xml - maybe this isn't such a biggie :) * using uris instead of accept content-type headers to influence the representation. most good frameworks tend to have a convention where you can, say, append ".xml" or ".json" or ".yaml" or whatever to force the representation without having to specify accept headers. while a bit of a hack it is kinda handy allowing folks to use any browser to view different representations - without relying on custom plugins in browsers etc. it might be nice to kinda standardise this kinda stuff. but those are tiny nits - these 10 anti-patterns are right on the money! keep it up! :) reply, back to top we seem to have similar timing ;) jul 8, 2008 7:01 am by benjamin carlyle <p>i was mulling over the phrase "rest patterns" as it was coming up as a training need in my office. i'm focusing on patterns for machine-to-machine communication, but have started to collect a few myself: rest patterns @ soundadvice.id.au</p> <p>i have quite a bit more work to do, and i still have to clear up some cloudy ip issues before i am able to get out my complete list :-/</p> reply, back to top re: tunneling through post jul 9, 2008 1:28 am by bryan taylor soap uses a rich (non-uniform) interface, because that's what you do when you program with objects, and soap tries to mimick this. so you're argument for the uniform interface is really one against object oriented programming generally, as you haven't told me any web specific reason to necessitate the switch of architectural style. somehow i don't think object oriented coding would be as popular and successful if it was as brittle as you say something without the uniform interface must be. <p/> i also have to question the idea that restful resources are normally "self describing". in fact, this is a key weakness of rest that presently prevents widespread adoption of in enterprise settings (at least until wadl or wsdl 2.0 gain more traction there). the idea that you won't have to redeploy a new client if the server behavior changes in rest is a bit far fetched for the same reason. the fact that hypermedia has embedded uris doesn't mean that client code knows how to translate these uri into a semantic meaning, nor does it protect the client from having to be changed if new state transitions are added or others are taken away. application code must understand the interchange format in detail. rest gives you no way to say anything more descriptive than the media-type such as "application/xml". when i do a get, i may discover that i don't understand the payload or that it's changed from what my client code supports. the wonderful state machine via links is then useless to me. without service descriptions, such changes happen without warning at runtime and break things, even if i got to the /account/1234 doc by following hateous navigations. moreover, if i'm a client constructing a post or a put, i don't even have the benefit of an example. i have no way to know what the payload i should construct must look like, other than xml. <p/> reply, back to top re: tunneling through post jul 10, 2008 8:29 am by benjamin carlyle <p>brian, </p> <p>it is probably best to avoid emotive words like "rich" when comparing rest to the classical o-o style. a fairer comparison might be "unconstrained" (oo) vs uniform (rest). </p> <p>rest and o-o are closely related. they are both typically client/server request/response messaging paradigms. the client has a reference to the server, and sends it a message. rest is a constrained form of o-o for systems with appreciable network latency, bandwidth constraints, a number of different owners and different release cycles for different components of the architecture. </p> <p>perhaps the clearest contrast is between rest and a strongly-typed o-o language. in nice, crinkly java i get a compile error whenever two components disagree on the definition of an interface. the client tries to call method foo. there is no method foo. bail. in this setting it makes sense to leverage the strongly-typed nature of the language to make sure you don't release junk. you define interfaces in a detailed and domain-specific way that is checked to yield a consistent releasable whole. </p> <p>in rest, i want the client or the server i deployed literally 10 years ago to work with whatever i am putting out today. i also want whatever i'm putting out today to work with every bit of code written since that time, and every bit of code that will be written in the next 10 years. getting more specific than necessary is a sub-optimal approach in this environment. there is no compiler to lean on to ensure consistency, and there is no way you could "fix" the old deployed code to work with your latest and greatest. instead, we lean less on checking and more on uniformity. you don't want to call out thirty or forty versions of an interface that you adapted as your needs changed, and provide explicit support for each. you want something generic, stable and slightly sloppy. </p> <p>it's not a matter of rest rejecting o-o, or for that matter replacing o-o. it's a matter of different contexts. the growing importance of rest is a recognition that the important bit of software architecture is moving away from "how do i get a release of my project out" to "how do i get my system to work with the other 15 business systems either deployed or in the process of being deployed? how do i future-proof this system in face of constant change?"</p> <p>to answer your points: yes, we need better descriptions of what specific urls are going to do with our put and get requests. whether that is a matter of producing more machine-readable content or simply more human-readable content is still up for grabs. yes, we need better document types... the kinds of document types you only come up with by solving real problems. no, i don't think the rest community is at the tipping point where they are solving these problems well enough. i'm hoping they'll/we'll be there soon. at least we know that document-oriented soa is in the same boat with some of our problems.</p> <p>see also my get pattern description. i welcome feedback on this and other pattern descriptions.</p> <p>benjamin.</p> reply, back to top re: put, post, and uris for creating new resources jul 13, 2008 6:04 pm by markus krüger 201 created is (mostly) used after a put to create a new resource. the target url is typically a generic one (eg. /blogposts or /blogposts/*), since often the server builds the unique url for the resource. the 201 confirms the creation and gives the client the information where the new resource can be found now. if you're using put, you should use the specific url the resource should be stored under, not some generic url. if you want to create a new resource without specifying the resource url, the api should use post instead of put. from rfc 2616, chapter 9.6: the fundamental difference between the post and put requests is reflected in the different meaning of the request-uri. the uri in a post request identifies the resource that will handle the enclosed entity. that resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. in contrast, the uri in a put request identifies the entity enclosed with the request -- the user agent knows what uri is intended and the server must not attempt to apply the request to some other resource. if the server desires that the request be applied to a different uri, it must send a 301 (moved permanently) response; the user agent may then make its own decision regarding whether or not to redirect the request. reply, back to top re: question on "ignoring status codes" jul 24, 2008 6:53 am by sebastian kirsch i assume that redirection means 2 requests from browser: 1) create (or any action) request - as post 2) redirection request to get the resource - as get. while most of the mvc frameworks will return the view after the action in a single request. is this the cost we have to pay for a cleaner architecture? or is there a better way? i always assumed that if a put is processed successfully, the server should respond with 1) a 201 sc 2) the representation of the created resource as it would be returned by serving a get request referring to markus' comment, i'd agree that a put affects the addressed resource and thus there should be no need for a location header - though it makes great sense when using post to create resources. another thing i'd expect to find in a put response is caching information: expires header, etag and - here i contradict myself - maybe even the location header, as i wouldn't rely on a proxy/gateway to cache things if that header isn't present. why? the proxy/gateway should then be able to serve a plain get request for that resource without forwarding the request to the server even once. reply, back to top "ephimeral" resources jul 24, 2008 2:10 pm by martin sarsale first of all, great article. your checklist works pretty good against my api implementation, but i was missing hyperlinking, which makes a lot of sense. this is a more open question, which maybe fits better in a forum. anyway, here it goes: i'm kind of puzzled on how to expose "ephimeral" resources, for example, the output of a search. i understand the search results are 'a resource' but i'm wondering if there's any rule to create urls for those. for example, api.foo.com/search/foo+bar/ and, what happens with paginated searches. do you like this: api.foo.com/search/foo+bar/1 i would love to use "content-range" but i think it's forcing things a little bit :) anyway, really enjoyed the article. reply, back to top re: great stuff, be good to read more aug 11, 2008 3:45 pm by colin jack thanks for the link, really good content. i'll try to think of a good example but this one gave me a lot of good information. reply, back to top re: question on "ignoring status codes" sep 3, 2008 8:55 am by matthias wauer i always assumed that if a put is processed successfully, the server should respond with 1) a 201 sc 2) the representation of the created resource as it would be returned by serving a get request not necessarily. rest also allows put for updating complete existing resources. therefore, a 200 sc (or, more common, a 204 no content) may be more appropriate, depending on the existence of the targeted resource. reply, back to top re: great stuff, be good to read more sep 3, 2008 4:47 pm by colin jack stefan, i think the travel agency service from ch10 in "restful web services" would be a good example. i actually think the authors missed a trick not exploring the travel agency application in more detail. not to say social bookmarking examples aren't interesting but really i think most examples of services that "have a different grain than the rest of the web" would be useful. reply, back to top another example for a "rest api" that isn't really restful? sep 21, 2008 11:41 am by eike herzbach here help.launchpad.net/api it says: the service is designed around the principles of rest, with the goals of simplicity and transparency. when looking into the documentation, you find stuff like custom post methods: acceptinvitationtobememberof addmember declineinvitationtobememberof what are your thoughts about this? reply, back to top re: another example for a oct 24, 2008 12:29 am by stefan tilkov without having taken a closer look, this seems to show either a misunderstanding of rest or unwillingness to label things correctly :-) it seems like a classical example of post tunneling. reply, back to top re: question on oct 24, 2008 9:00 am by alex popescu 201 created is (mostly) used after a put to create a new resource. the target url is typically a generic one (eg. /blogposts or /blogposts/*), since often the server builds the unique url for the resource. the 201 confirms the creation and gives the client the information where the new resource can be found now. i might be wrong about it, but i was having the impression that put requests are (required to) providing the new/updated resource identifier and what you are explaining applies in fact to post. ./alex reply, back to top re: question on oct 24, 2008 9:02 am by alex popescu it looks like markus is agreeing with my point in the next comment :-). ./alex reply, all, articles, presentations, interviews, minibooks, ,  dec 23, 2008,,  , ,  dec 22, 2008,,  , ,  dec 19, 2008,,  , ,  dec 17, 2008,,   7, ,  dec 16, 2008,,   10, ,  dec 15, 2008,,  , ,  dec 12, 2008,,  , ,  dec 11, 2008,,  , older >]