[feb 2015 paul irish this doc is public, , protip for reading this doc:, turn off print layout, , , , read on! , , profiled feb 18th, paul irish, , open up cnet, and tap on the hamburger menu to enjoy a really painful jank during the nav slideout:, , , , up front is a lot of js cost adding latency before we see any effect. then a 200ms-long animation that appears to do layout in every frame., , , , , clearly, we’ve blown our midnight train budgets of 100ms for input latency and 6ms of work per animation frame., , let's dig in and see what's up!, , , , let's zoom to the first chunk:, , , we have newrelic wrapping bugsnag wrapping settimeout., it's google adsense doing 24ms of work, every 1000ms. but in this case it fired right as my finger hit the hamburger icon., , next, we have some mousedown handlers:, , looking closer, one of the handlers is some event delegation looking for a very specific selector ([data-user-show] which i've never spotted in their dom). but, obviously handling this mousedown delays every touch., , , , finally we get to the click handler that does the work:, , , the revised flame chart coloring (by file) makes it easy to see our code vs jquery.js., , clicking into the layout we see that our layout thrashing comes from the same source line (118):, , , here it is:, this.$element.on("click", function() {    e("body").toggleclass("m-view-nav"); window.scrollto(0, 0); }), , they're using a class on the <body> to trigger the effect. obviously this invalidates the style & layout for the entire page. :/, , then, they curiously call scrollto(0,0); this is to jump the page back to the top of the screen because the nav, at rest, is positioned up there:, , , however this scrollto(0,0) ends up forcing a 25ms layout they probably didn't need., , once the "m-view-nav" class is in place, the animation gets triggered., , the nav panel  gets a css transition on layout property left:, , , and the content-panel also shimmies to the left as well:, , , so they have two elements, independently animating with the same duration, and hopefully it looks like they move in concert., watch the full 60fps video of the 15fps sidenav slide., , , , profiled feb 24th, paul irish, , , test page: www.cnet.com/news/netpicks-whats-new-on-netflix-and-amazon-online-for-march-2015/ , , fling it to scroll it. we'll scroll at maybe 13 fps, if we're lucky., , , , , we have some touch handlers that push us into slow scrolling mode., , , , plenty, plus a lot of handlers on scroll itself.   this scroll handler below was on the shorter side (21ms) of ones i’m seeing (avg 35ms)., , i investigated each handler to see what they’re up to:, , all of these run on every scroll event. it appears that the scroll is blocked on completion of these handlers., , , newrelic wraps around every event handler in the page and grabs date.now() on both sides of each., , every 500ms, yahoo ads runs this, querying scroll and size metrics of their iframe., var b = a.iframerelativescrollposition(d); a.sendpostmessage({    action: "scroll",    scrolltop: b[0],    scrollleft: b[1],    height: a.iframerelativeheight(d),    width: a.iframerelativewidth(d) });, , every 1000ms, google adsense runs 30-40ms of js., , every 1000ms, another google ad network runs a good amount of js., , my favorite: a loading spinner, that’s a canvas element, is rotated with css transforms every 42ms, via setinterval., , , obviously 42., , , , , profiled feb 2015, paul irish & pavel feldman, , scrolling time.com/3703410/uma-thurman-face-red-carpet/ during loading on clank is a great devil case. i regularly see it paused for 5 seconds., , i recommend you turn on “show touches” in developer options. you can leave it on permanently., , it helps you evaluate latency between android os receiving your touch and the result., , , for this audit we won’t look at scrolling during load, but just a scroll fling, well after the page has loaded., , , , looks like a lot of js. let’s validate its the js causing the problem. turn on show scrolling bottlenecks:, , , we’ve got a mousewheel handler somewhere. hard to see exactly where, though., , we can actually look a little deeper here., , if i record timeline with paint checkbox checked, we can inspect the layer tree and investigate if any have scroll scrolling behavior:, , it’s telling us we’ve got at least a gallery lightbox with a touch handler. and all that pink indicates more than just that element has a slow scrolling reason., , , so, let’s see what’s going on in our blocking event handlers, , , i wasn’t happy with all these handlers so i nuked them all to see a difference., you can navigate all event handlers via the listing per element or use the console to grab them and trash them., , , , , , after looking at the yellow haze of unclean slow scrolling for a while,, the event handlers are gone and the content emerges., , , , , scrolling the page gently, the start of the touch, visible on uma, is synchronized., here, we can see the impact of those handlers more clearly., , , , , the same scroll now in timeline…, , before:, , , after:, , , this is already at least a 2x improvement. great stuff, but towards the end some js comes and ruins the 60 fps party., , , digging into these frames we have a 23ms scroll handlers and a 6ms raf., , are these long scroll handlers busting our frame budget repeatedly?, , for simplicity i’ll remove these handlers as well:, , , any better?, , not really., , there’s a lot of timer-based js running., , on a hunch, i recorded the page at idle, not touching anything., , busy busy busy!, , all this work comes from some 3rd party code, churning in the background:, , , , and the recurring raf is a flash → html5 runtime, somewhere on this page., , , , but, lets back up, all that green paint work i saw during scrolling..  , let’s see what it’s for., , flip on paint profiler to see what we were so busy with:, , we’re repainting this one ad a few frames in a row., it’s not terribly expensive, just 3.5ms each time, but we’re paint storming on it. not sure why., , but in addition to these paints, we spend a lot of time compositing., , , why so much compositing cost?, , , layers. layers like mad., the side nav that’s not on screen has 28 layers.  youch., , we can still do better. let’s get to our goals., , there was one ad network firing a visibility checker every 100ms. i ripped it out and tried my scroll again:, , , oh yes., , and as a last-ditch effort, i display:none’d the two layer-heavy dom subtrees to see if i could reduce the compositing costs., , yup. nice reduction in my green jank. that’ll do., , , so, looking at our grand before/after…, , , , , obviously, there’s a lot less work happening in each frame. we haven’t disabled all javascript, just removed our handlers for touch, wheel and scroll. and nuked a few very costly setintervals., , but the important thing is we’ve finally hit our midnight train goal of 60 fps, and believe me, the scrolling experience feels so so good., , , the inability to scroll at the start isn’t fully an input latency concern., the full page’s content isn’t available. below, a 4s gap between these paints., , , , inside these two frames is a bunch of js taking up 4200ms:, , , the js ends up being backbone doing clientside templating of ads and navigation menus. luckily, the primary article’s content was already delivered in the html., , , , , , , , we investigated the desktop experience of the wikipedia visual editor along with their engineers., test page: https://en.wikipedia.org/wiki/barack_obama?veaction=edit, , , , full size , , the result gives us about three equal size sections of activity. let's look at each third as an act., , ,         $img = $imgwrapper.children('img').eq(0),,         $caption = $figure.children('figcaption').eq(0),, , , , , , here, wikipedia is annotating the timeline recording's phases of load with post-its and markers., how does one print out the timeline? with wikipedia, we found a creative solution: inspect the inspector, use device mode in desktop mode, stretch viewport to 9000px wide, grab the timeline's <canvas>, todataurl() it, set to img[src], download, print., , https://phabricator.wikimedia.org/project/board/831/query/jni8_pet.ggl/ is tracking the eng team’s progress. they’re already made large and substantial improvements. i’ve seen the performance speed up by over 2x already., addy osmani’s recent talk from jquery uk covers this story as well., , , working through this example reveals a lot of ways in which we could help to communicate everything above without an expert walking through the timeline., , , , , , , , other recent perf audits:, , angular app input latency rendering form fields , angular’s dominance of the runloop means the developer has few options, aside from large refactors., not only does it load in 80 scripts, connect to 80 origins, create 70 frames, and load 5mb of content…  but, as you can imagine, it thrashes the main thread in no particular pattern, so there's not much fruit hanging low on these sfgate trees., greg simon said this destroyed his chrome pixel. indeed, this particular site is a great stress-test for our entire platform., yelp published a blog post, animating the mobile web, describing how they got to 60 fps.  , we dug in to look a bit closer., , , , , , , , , profiled by paul irish & paul lewis, feb 27th., , viewing https://play.google.com/store/movies/category/1/collection/topselling_paid on desktop., , 1 second long scrolling janks when the infinite scroll xhrs returns and generates dom., , , the xhr handler should definitely yield instead of creating all their dom immediately., , but while they do their work in one go, the mousewheel handler means the user scroll is blocked., , at the end of our timeline recording are these gray towers., , this points to work that devtools doesn’t have instrumented.  but tracing likely does…, , , , the culprit here: compositingrequirementsupdater::updaterecursive, , , as a hunch, we thought this cost was ballooning with layer count., , , first you open up layers panel and you’re thinking..,  oh a layer per card. that seems excessive., , but then you tilt it and see we have 3 unique layers per card., , , while we’re here, that red looking layer is the one with the wheel handler. but oddly it’s showing up behind the root layer, which shouldn’t probably be possible. in fact, if we look at google.com:, , , , so let’s park this, because it’s just how chrome’s internals are set up that there’s a wheel handler., , if we drop backface-visibility from the card, our layer count drops to 1., , and we’ve vanquished the timeline’s gray towers of layer management., , , , however, we have a new problem., , , every time we render a new card to the page we need to re-rasterize the entire viewport., given that, it’s no surprise painting 1450 x 12,000 pixels takes 80ms each frame., , , for fun, i used devtools liveedit to edit the xhr handler’s javascript live and put a wrapper around each new “page” of elements, which i then promoted with will-change:transform., now our layer creation and repaint is synchronized with the dom changes., , , , , , , , it ended up making a great improvement:, , , , , 3 layers per card , (original), a single layer,  a few layers to group card additions, mega paints, (length of large paint operations), 130ms, 121ms, 30ms, post-load frame times, 220, 220, 230, 200, 310, 210, 110, 100, 200, 75, 70, 50, , looks like a win., , remember that big xhr?    upon further inspection, it interesting:, , , , ][, the 1000/100/6 model establishes strong bounds of focus for investigating performance concerns. with a focus on load, input latency, and fidelity of animation and scrolling, we are drilled into the aspects that most directly impact the end user experience., in the audits below, we’ll investigate a few sites’ performance from this pov. for a start-to-finish guide of using devtools in your own perf audit see pfeldman’s sfgate.com devtools walkthrough, this document is fairly long (but worth it!), so a brief table of contents…, cnet side-nav slide-out, input latency, layout animation, insights, developer-facing insights, devtools-facing insights, blink-facing insights, cnet scrolling, scroll handler walkthrough, in-page js profiling, setinterval costs, insights, developer-facing insights, devtools-facing insights, blink-facing insights, time.com scrolling, 6 touchstart/touchmove handlers, 3 scroll handlers, 1 mousewheel handler, sayonara synchronous handlers, before and after heavy input handlers, paint & compositing, finishing up, no changes, as it sits live today:, our improvements applied:, update (march 18th):, insights, developer-facing insights, blink-facing questions/insights, wikipedia webapp startup, let's take a timeline., summary for wikipedia developers, update (feb 25th), wikipedia dev team hard at work:, update (march 19), plenty of fixes are in, devtools insights, communicating top costs, connecting back to source, profiler experience, buggy stuff, additional feedback from wikipedia (march 18), want more?, sfgatepocalpyse | the pageload of sfgate.com (google only, sorry!), yelp mobile web | touchmove effect (google only, sorry!), scrolling jank in google play movies infinite scroll, mystery cost, post xhr, layers, wheel handler detour, lets nuke those layers, so did we improve the jank, post xhr?, xhr, developer insights, devtools insights, blink insights]perf audits for blink & devtools, cnet, wikipedia, time[][cnet side-nav slide-out, cnet scrolling, time.com scrolling, wikipedia editor, google play, infinite scroll, don't use event delegation for any events that can add to input latency (touchstart, touchmove, touchend, mousedown, click)., take inventory of all event handlers and determine if they're necessary to run then., don't animate elem.style.left. animate transforms., don't use something so global as document.body.classname for nav toggling as it invalidates the world, need to see when the finger lands to evaluate latency easier., could use easier mechanism to match the “m-view-nav” toggleclass call with styles/elements affected., could use easier mechanism to investigate js stacks and sources repeatedly., we know when layout animations happen. we know when `left` is used in css transitions. we need to warn the developer., how would they achieve this effect the right way?, css transition on transform:translate on a container that's around both the content & nav, position:fixed to keep the nav next to the content regardless of scroll position, (added) scrollto(0,0) should be a no-op if we’re already at 0,0, (added) scrollto shouldn’t force layout, …, [data-user-show] returns!  queryselectorall("[data-user-show]") is checked during touchstart. it takes a decent 8ms to look up., and it’s.. checked during all of these events, as well:, , jquery mobile binds to touchstart. they’re greedy with their binds, , they don’t do any work during the handler, so it’s a noop., youtube instream videos records that a finger has touched the screen., jquery mobile tracks the distance moved by the finger., jquery mobile tracks the finger has left the screen and issues a virtual mouseup event, jquery scrollstart catches first, installs a timer and bails, jquery lazyload plugin next., luckily in this case it’s disabled., when it’s enabled it heads down this path:, , the :visible selector check requires a getcomputedstyle, and the other metrics look at scrolltop() and elem.offsettop repeatedly, youtube instream video ads. runs 6ms of script., 6ms is a lot of time to spend in v8, and all it really winds up doing is… this.keyvalues[‘touch’] = 0 + 1;, google adsense is the big poppa of the bunch, and it wants to know about every scroll, too., they collect a bunch of metrics then postmessage it to their iframe., takes ~25ms on my phone., yahoo ads, checks to see if an element is within the viewport. asks for pagexoffset and innerwidth, youtube instream video ads. back again, tell google adsense this is unacceptable. :), take inventory of extra handlers and remove unnecessary ones (scrollstart, lazyload), change new relic configuration to only add an instrumented profiler to 1% of users. (ideally), get developers attention with poor scrolling performance and nudge them towards what is adding most of the cost, summarize event handler cost by file, to easily blame 3rd party scripts, element visibility api?, synchronous, cancelable, blocking event handlers are the worst, amirite?, we appear to be handling the scroll event synchronously. why?, what else?, evaluating visibility of article, likely for if it was read, getsboundingclientrect() call within each, first, setactivearticle(), then record it in analytics and conditionally place an ad if things are onscreen or off., evaluating visibility of an ad rotator, evaluating visibility of some other things., seeing if the user is active. (bound to ["resize", "scroll", "touchmove"]), call maybeloadhiddenimages() if its time to lazy load images, 30ms to do a very expensive jquery dom traversal: $("body").find("img").not("[data-loaded]"), on every touchstart, yes., exact same article visibility check., infinite scroll checks on viewport size and element positions to potentially load new content, the scroll handlers are the most costly but sometimes fire before touchmove and appear to block, maybeloadhiddenimages() again., costly event handlers introduce latency to scroll and reduce the framerate post-fling., reduce layer count if possible., any flash ad that’s being transpiled to html5 clientside is more costly than it should be. ask your advertisers to do it right., what is the best approach for handling this long-article infinite scroll setup?, what api should ad networks polling for user activity use?, how best to load images lazily, so they don’t influence pageload but don’t require touch/scroll handlers?, viewportobserver?, flush the document to render before issuing domcontentloaded?, …?, profiling the full load of https://en.wikipedia.org/wiki/barack_obama?veaction=edit  starting up., timeline: causes & js profiler on., avoid $.getvisibletext . it requires a very heavy recalculate style because its using the :hidden selector., recommendation: use your own logic to compute visibility that doesn't rely on getcomputedstyle, or defer the work., jquery.filter is called via ve.dm.mwblockimagenode.static.todataelement. it is hugely hugely expensive., a closer look and it's this:   $imgwrapper = $figure.children('a, span').eq(0),, dom size in general is going to be a big overarching factor here., recommendation: kill any superfluous spans/divs you don't absolutely need, sizzle is repeating a support.getbyid call. probably a bug. if you go straight qsa you'll avoid a lot of cost, we're generating a lot of garbage so the gcs are huge. lower-priority, but something to eventually chase down, don't use jquery.html() inside of inside of ve.dm.internallist.converttodata. you don't need it and innerhtml is massively faster., recommendation: use innerhtml just once instead of stamping out html into dom many many times. (not 100% you are doing it multiple times though…) either way its taking forever, the next 1/3 of editor initialization is mostly time inside of ve.init.target.createsurface calls. treewalking?, use console.profile() / profileend() to capture just this section and view in js profiler (heavy), more massive recalc styles., lots of $(elem).hide() and some $(elem).css(property) coming from veuicontext and oo.ui.listtoolgroup., triggering recalcs that are 100ms each, , jquery animations triggering recalc style, more $(elem).hide(), jquery asks for computedstyle when you tell it to hide an element. it’s a problem., issue raised: https://github.com/jquery/jquery.com/issues/88#issuecomment-72400007 , wikpedia feedback: "yeah, there are a lot of $.show / $.hide calls that are wasteful because they're toggling the visibility of something we know is hidden or visible", oo.copy does a lot of js only work. called enough to warrant micro-optimizations, wikpedia feedback: "oo.copy is used to deep-copy the entire visualeditor dom so we can round-trip it once to confirm that the editor can handle it without introducing corruption. i'm working on eliminating that entirely.", another style recalc forced by ve.ce.surface.showselection, because of  this.nativeselection.addrange(nativerange);, more of this ve.dm.mwreferencenode.static.todomelements action, $(el).html(str) non-stop. use innerhtml instead, try to add it to the dom once., the very end oo.ui.popupwidget.toggle ends up triggering another massive recalc style., you need to determine visibility on your own so that you don't require on getcomputedstyle for that, jquery is not your friend here., eradicate :hidden , hide() and toggle() from the codebase., jquery is doing too much magic around queryselectorall. just use it alone., don't use $(elem).html(str) for dom insertion, use innerhtml or dom methods. use doc fragments if necessary. try to add to the page at once., way too much forced style recalc and layout. track down all the reasons why., track visibility on your own, do not use getcomputedstyle to ask., don't build the dom just to hide() it., dom size is too big., if you can't kill the recalc styles need to isolate the recalc costs better. iframes? :/, we need a view of the overall performance so we don't go to micro immediately., need a summary similar to the timeline summary tooltip, developers have jsperf for the micro picture. if they're profiling, they want the big picture, we get big callstacks thanks to libraries & frameworks., fade blackboxed frames in flame chart. easier view in callstack, need better association between details frame callstack and the flame visualization., we need range selection for heavy profiler view., highlight on hover, things like $figure.children('a, span') don't feel expensive but we need to show they are., show original source lines of the key frame from callstack?, while hovering callstack, show the relevant line of source, heatmap potentially useful during authoring. use previously collected perf data to annotate., what is the "heavy" equivalent of timeline?, summary view, forced style recalcs: 30% of main thread time, pure js (not ending in purple/blue): 30% of main thread time, event handlers (blocking): wheel/touch., event handlers (non-blocking): mutation events, stack view for each of these, blackboxing jquery etc.  , developer view:, gather all stacks for recalc/layout/etc , reverse them, magically match them, then summarize with total amount of work caused by each call., prioritize forced stack frames. guide them to address layout trashing. only draw developers towards invalidation if they need it to re-order., bug identified: insertbefore call not part of our invalidation call stack, timeline frames view gets confused. when we're not frequently spitting out frames, each vertical frame bar can capture 1-2s of work., we should use frames view when reasonable (raf, animation or scrolling) and use regular otherwise., could they be on the same line?, v8 deopts are loud and demand priority however they rarely deliver significant improvements in overall performance., true., devtools audit panel is not good., it recommended "3 inline script blocks were found in the head between an external css file and another resource. to allow parallel downloading, move the inline script before the external css file, or after the next resource. ", wikipedia followed the advice with no improvement to be found., printing out the timeline to investigate was incredibly effective., 2 at the card location, one of which is manually promoted with backface-visibility, the other layerforsqashingcontents, a third layer per-card is the full width and height of the document. (layerforancestorclip), don’t ask for element/window metrics while/after adding new content to dom, reduce layer count to minimize overhead, need a global layer count, need to indicate what actions to take given a particular big cost, e.g. composite layers == reduce layer count. investigate current ones via frame viewer and evaluate compositing reasons, scrolltop is asked for often and requires significant work. do we need to force a layout for all cases?, why are we generating two superfluous layers per movie card?, optional: infinite scrolling with single layer can add up to significant re-rasterize costs. can we chunk out the primary layer so the cost isn’t so large?]